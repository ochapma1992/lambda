    @patch('src.arti_cleanup.arti_cleanup.Config')
    @patch('src.arti_cleanup.arti_cleanup.ArtifactoryClient')
    def test_filter_artifacts_for_archive(self, mock_client_class, mock_config_class, mock_artifacts):
        """Test artifact filtering logic."""
        mock_config_class.return_value = Mock()
        operation = ArchiveOperation(days=5, dry_run=True)

        operation.parser = Mock()
        operation.parser.parse_package_name.side_effect = [
            {"package": "PackageA", "version": "1.0.0"},
            {"package": "PackageA", "version": "2.0.0"},
            {"package": "PackageB", "version": "1.0.0"}
        ]
        operation.parser.parse_timestamp.side_effect = lambda x: datetime.fromisoformat(
            x.replace('Z', '')) if x else None

        filtered = operation._filter_artifacts_for_archive(mock_artifacts)

        # Should archive PackageA.1.0.0 (old version of PackageA) 
        # but keep PackageA.2.0.0 (recent) and PackageB.1.0.0 (only version)
        assert len(filtered) == 1
        assert filtered[0]["name"] == "PackageA.1.0.0.nupkg"




    def _filter_artifacts_for_archive(self, artifacts: List[Dict]) -> List[Dict]:

        # Parse package information for each artifact
        for artifact in artifacts:
            package_info = self.parser.parse_package_name(artifact["name"])
            artifact.update(package_info)

        # Group artifacts by package name
        packages = defaultdict(list)
        for artifact in artifacts:
            packages[artifact["package"]].append(artifact)

        artifacts_to_archive = []

        for package_name, versions in packages.items():
            if len(versions) <= 1:
                self.log(f"Skipping {package_name}: only one version available")
                continue

            # Sort versions by download activity (most recent first)
            versions.sort(key=self._get_sort_key, reverse=True)

            # Categorize versions as recent or old
            recent_versions, old_versions = self._categorize_versions(versions)

            if recent_versions:
                # Keep recent versions, archive all old ones
                artifacts_to_archive.extend(old_versions)
                self.log(f"{package_name}: Keeping {len(recent_versions)} recent, archiving {len(old_versions)} old")
            elif len(old_versions) > 1:
                # No recent activity, but keep the newest old version
                artifacts_to_archive.extend(old_versions[1:])
                self.log(f"{package_name}: No recent activity, keeping newest, archiving {len(old_versions)-1} old")

        return artifacts_to_archive


    def _get_sort_key(self, artifact: Dict) -> Tuple[datetime, datetime]:
        epoch = datetime.fromtimestamp(0, tz=timezone.utc)

        last_activity = self._get_last_activity_timestamp(artifact)
        created = self.parser.parse_timestamp(artifact.get("created"))
        print(
            last_activity or epoch,
            created or epoch
        )
        return (
            last_activity or epoch,
            created or epoch
        )








============================== 1 failed in 0.37s ===============================
FAILED [100%]2025-08-10 11:31:27.711000+00:00 2025-08-10 11:31:27.711000
2025-08-19 11:31:27.711000 2025-08-19 11:31:27.711000

test_arti_archive.py:235 (TestArchiveOperation.test_filter_artifacts_for_archive)
self = <test_arti_archive.TestArchiveOperation object at 0x7fc3fee84cd0>
mock_client_class = <MagicMock name='ArtifactoryClient' id='140479771987056'>
mock_config_class = <MagicMock name='Config' id='140479771995312'>
mock_artifacts = [{'created': '2025-08-10T11:31:27.711Z', 'name': 'PackageA.1.0.0.nupkg', 'package': 'PackageA', 'path': '.', ...}, {'c......}, {'created': '2025-08-10T11:31:27.711Z', 'name': 'PackageB.1.0.0.nupkg', 'package': 'PackageB', 'path': '.', ...}]

    @patch('src.arti_cleanup.arti_cleanup.Config')
    @patch('src.arti_cleanup.arti_cleanup.ArtifactoryClient')
    def test_filter_artifacts_for_archive(self, mock_client_class, mock_config_class, mock_artifacts):
        """Test artifact filtering logic."""
        mock_config_class.return_value = Mock()
        operation = ArchiveOperation(days=5, dry_run=True)
    
        operation.parser = Mock()
        operation.parser.parse_package_name.side_effect = [
            {"package": "PackageA", "version": "1.0.0"},
            {"package": "PackageA", "version": "2.0.0"},
            {"package": "PackageB", "version": "1.0.0"}
        ]
        operation.parser.parse_timestamp.side_effect = lambda x: datetime.fromisoformat(
            x.replace('Z', '')) if x else None
    
>       filtered = operation._filter_artifacts_for_archive(mock_artifacts)

test_arti_archive.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.arti_cleanup.arti_cleanup.ArchiveOperation object at 0x7fc3feeb8be0>
artifacts = [{'created': '2025-08-10T11:31:27.711Z', 'name': 'PackageA.1.0.0.nupkg', 'package': 'PackageA', 'path': '.', ...}, {'c......}, {'created': '2025-08-10T11:31:27.711Z', 'name': 'PackageB.1.0.0.nupkg', 'package': 'PackageB', 'path': '.', ...}]

    def _filter_artifacts_for_archive(self, artifacts: List[Dict]) -> List[Dict]:
    
        # Parse package information for each artifact
        for artifact in artifacts:
            package_info = self.parser.parse_package_name(artifact["name"])
            artifact.update(package_info)
    
        # Group artifacts by package name
        packages = defaultdict(list)
        for artifact in artifacts:
            packages[artifact["package"]].append(artifact)
    
        artifacts_to_archive = []
    
        for package_name, versions in packages.items():
            if len(versions) <= 1:
                self.log(f"Skipping {package_name}: only one version available")
                continue
    
            # Sort versions by download activity (most recent first)
>           versions.sort(key=self._get_sort_key, reverse=True)
E           TypeError: can't compare offset-naive and offset-aware datetimes

../arti_cleanup/arti_cleanup.py:220: TypeError

Process finished with exit code 1


